"""
Kernel dump file parser using kdmp-parser.

Parses Windows complete memory dump files generated by WinDbg (.dump /f).
"""

from pathlib import Path
from typing import List, Optional, Dict, Any
from datetime import datetime
from loguru import logger

from bsod_analyzer.database.models import (
    MinidumpInfo,
    CrashInfo,
    DriverInfo,
    StackTrace,
    StackFrame,
)


class KernelDumpParser:
    """Parser for Windows kernel dump files using kdmp-parser."""

    def __init__(self, file_path: str):
        """Initialize the kernel dump parser.

        Args:
            file_path: Path to the dump file
        """
        self.file_path = Path(file_path)
        self._dump = None
        self._validate_file()
        self._load_dump()

    def _validate_file(self):
        """Validate file exists and is accessible."""
        if not self.file_path.exists():
            raise FileNotFoundError(f"Dump file not found: {self.file_path}")

        if self.file_path.stat().st_size == 0:
            raise ValueError(f"Empty dump file: {self.file_path}")

        # Check for supported signatures
        with open(self.file_path, "rb") as f:
            signature = f.read(8)

            # PAGEDU64 = Windows complete memory dump (not supported by kdmp-parser)
            if signature[:8] == b"PAGEDU64":
                raise ValueError(
                    "Windows complete memory dump (PAGEDU64) format is not supported. "
                    "Use WinDbg, BlueScreenView, or change system settings to generate "
                    "minidump or kernel dump (.dump /f in WinDbg) format."
                )

            # PAGEDUMP = 32-bit variant
            if signature[:8] == b"PAGEDUMP":
                raise ValueError(
                    "32-bit kernel dump (PAGEDUMP) format is not supported. "
                    "Use a 64-bit system or minidump format."
                )

            # MDMP = Standard minidump - should use MinidumpParser instead
            if signature[:4] == b"MDMP":
                logger.warning("This is a minidump file. Consider using MinidumpParser instead.")

    def _load_dump(self):
        """Load the kernel dump file."""
        try:
            import kdmp_parser

            self._dump = kdmp_parser.KernelDumpParser(str(self.file_path))
            logger.info(f"Successfully loaded kernel dump: {self.file_path} (type: {self._dump.type})")
        except ImportError:
            raise RuntimeError(
                "kdmp-parser library not found. Install with: pip install kdmp-parser"
            )
        except Exception as e:
            raise RuntimeError(f"Failed to parse kernel dump: {e}")

    def parse(self, file_path: str) -> MinidumpInfo:
        """Parse and return dump basic information.

        Args:
            file_path: Path to the dump file

        Returns:
            MinidumpInfo object with basic information
        """
        # Get timestamp from file
        timestamp = datetime.fromtimestamp(self.file_path.stat().st_mtime)

        # Get CPU architecture from context
        arch = "AMD64"  # kdmp-parser only supports 64-bit dumps

        # Try to get system information
        computer_name = "Unknown"
        os_version = "Unknown"
        processors = 1
        memory = 0

        # Try to extract from directory table
        if hasattr(self._dump, "directory_table_base"):
            # Could potentially extract more info here
            pass

        return MinidumpInfo(
            file_path=str(self.file_path),
            file_size=self.file_path.stat().st_size,
            timestamp=timestamp,
            computer_name=computer_name,
            os_version=os_version,
            cpu_architecture=arch,
            number_of_processors=processors,
            physical_memory=memory,
        )

    def extract_crash_info(self) -> CrashInfo:
        """Extract crash information from kernel dump.

        Returns:
            CrashInfo object with crash details
        """
        # Get bugcheck code and parameters from exception record
        bugcheck_code = 0
        crash_address = 0
        parameters = []
        crash_thread_id = 0

        if hasattr(self._dump, "exception") and self._dump.exception:
            exc = self._dump.exception
            bugcheck_code = exc.ExceptionCode
            crash_address = exc.ExceptionAddress
            crash_thread_id = getattr(exc, "ThreadAddress", 0)

            # Get bugcheck parameters (usually 4 parameters)
            if exc.NumberParameters > 0:
                parameters = [
                    exc.ExceptionInformation[i]
                    for i in range(min(exc.NumberParameters, 4))
                ]

        # Get bugcheck name and description
        bugcheck_name, bugcheck_description = self._get_bugcheck_info(bugcheck_code)

        return CrashInfo(
            bugcheck_code=bugcheck_code,
            bugcheck_name=bugcheck_name,
            bugcheck_description=bugcheck_description,
            crash_address=crash_address,
            crash_thread_id=crash_thread_id,
            parameters=parameters,
            exception_record={
                "exception_code": bugcheck_code,
                "exception_address": crash_address,
                "thread_id": crash_thread_id,
                "exception_parameters": parameters,
            },
        )

    def _get_bugcheck_info(self, code: int) -> tuple[str, str]:
        """Get bugcheck name and description."""
        from bsod_analyzer.core.bugcheck_kb import BugcheckKnowledgeBase

        kb = BugcheckKnowledgeBase()
        return kb.get_bugcheck_info(code)

    def get_loaded_drivers(self) -> List[DriverInfo]:
        """Get list of loaded drivers from kernel dump.

        Note: kdmp-parser doesn't directly provide driver list.
        This method attempts to extract driver information from memory.

        Returns:
            List of DriverInfo objects
        """
        drivers = []

        # Try to find loaded modules in kernel memory
        # This is a simplified version - a full implementation would walk the PS_LOADED_MODULE_LIST
        try:
            # Try to read the kernel's module list from memory
            # For now, return empty list as this requires complex memory parsing
            logger.debug("Driver extraction from kernel dump not fully implemented")
        except Exception as e:
            logger.debug(f"Error extracting drivers: {e}")

        return drivers

    def get_stack_traces(self) -> List[StackTrace]:
        """Get stack traces from kernel dump.

        Returns:
            List of StackTrace objects
        """
        traces = []

        try:
            # Get context (registers at crash time)
            if hasattr(self._dump, "context") and self._dump.context:
                ctx = self._dump.context

                # Create a simple stack trace from the context
                frames = [
                    StackFrame(
                        instruction_address=ctx.Rip,
                        module_name=self._find_module_for_address(ctx.Rip),
                        offset=0,
                    )
                ]

                # Add RSP as a hint for stack location
                if ctx.Rsp != 0:
                    frames.append(
                        StackFrame(
                            instruction_address=ctx.Rsp,
                            module_name="stack",
                            offset=0,
                        )
                    )

                traces.append(StackTrace(thread_id=0, frames=frames))

                logger.debug(f"Extracted {len(traces)} stack trace(s)")
        except Exception as e:
            logger.error(f"Error extracting stack traces: {e}")

        return traces

    def _find_module_for_address(self, address: int) -> str:
        """Find module name for given address.

        Args:
            address: Memory address

        Returns:
            Module name or "Unknown"
        """
        # Try to read virtual memory at this address to find nearby module headers
        try:
            # This is a simplified version
            # A full implementation would walk the VAD and loaded module list
            return "kernel"
        except Exception:
            return "Unknown"

    def get_exception_record(self) -> Optional[Dict[str, Any]]:
        """Get exception record if available.

        Returns:
            Exception record dictionary or None
        """
        if hasattr(self._dump, "exception") and self._dump.exception:
            exc = self._dump.exception
            return {
                "exception_code": exc.ExceptionCode,
                "exception_flags": getattr(exc, "ExceptionFlags", 0),
                "exception_address": exc.ExceptionAddress,
                "thread_id": getattr(exc, "ThreadAddress", 0),
                "exception_parameters": [
                    exc.ExceptionInformation[i]
                    for i in range(exc.NumberParameters)
                ] if hasattr(exc, "NumberParameters") else [],
            }
        return None

    def get_memory_regions(self) -> List[Dict[str, Any]]:
        """Get memory region information.

        Returns:
            List of memory region dictionaries
        """
        regions = []

        try:
            # Get directory table base (PML4)
            if hasattr(self._dump, "directory_table_base"):
                regions.append({
                    "name": "DirectoryTableBase (PML4)",
                    "virtual_address": self._dump.directory_table_base,
                    "type": "page_table",
                })

            # Add context info as a region
            if hasattr(self._dump, "context") and self._dump.context:
                ctx = self._dump.context
                regions.append({
                    "name": "Context (RIP)",
                    "virtual_address": ctx.Rip,
                    "type": "code",
                })
                regions.append({
                    "name": "Context (RSP)",
                    "virtual_address": ctx.Rsp,
                    "type": "stack",
                })
        except Exception as e:
            logger.debug(f"Error getting memory regions: {e}")

        return regions

    def get_context_info(self) -> Dict[str, Any]:
        """Get CPU context (register state).

        Returns:
            Dictionary with register values
        """
        if not hasattr(self._dump, "context") or not self._dump.context:
            return {}

        ctx = self._dump.context
        return {
            "Rax": ctx.Rax,
            "Rbx": ctx.Rbx,
            "Rcx": ctx.Rcx,
            "Rdx": ctx.Rdx,
            "Rsi": ctx.Rsi,
            "Rdi": ctx.Rdi,
            "Rip": ctx.Rip,
            "Rsp": ctx.Rsp,
            "Rbp": ctx.Rbp,
            "R8": ctx.R8,
            "R9": ctx.R9,
            "R10": ctx.R10,
            "R11": ctx.R11,
            "R12": ctx.R12,
            "R13": ctx.R13,
            "R14": ctx.R14,
            "R15": ctx.R15,
        }

    def read_virtual_memory(self, address: int, size: int) -> Optional[bytes]:
        """Read virtual memory at address.

        Args:
            address: Virtual address to read
            size: Number of bytes to read

        Returns:
            Bytes read or None if failed
        """
        try:
            # kdmp-parser provides read_virtual_page
            page_data = self._dump.read_virtual_page(address)
            if page_data and len(page_data) > 0:
                # Calculate offset within page
                offset = address & 0xFFF
                available = min(size, len(page_data) - offset)
                if available > 0:
                    return page_data[offset:offset + available]
        except Exception as e:
            logger.debug(f"Failed to read virtual memory at 0x{address:X}: {e}")

        return None
